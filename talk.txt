History of EVE JSON
  - Previous situation
    - fast.log
    - unified2
    - separate metadata:
       - http-log
       - tls-log
       - file-log
       ...
  - Announcement screenshot
  - Quick introduction

Missing documentation
  - syntax: downstream "end" users need to parse the format
    - some parsers/decoders need a struct to parse JSON byte array into
       -> see https://github.com/rhaist/surevego
       -> https://github.com/0x00-0x00/SuriLogger
       - alternative: tedious safety checking during parsing
  - semantics: What fields? What values? Dependencies between fields
  - Current documentation: screenshot
    - purely static, little detail information

Empirical approach
  - EVE JSON Implementation
    - libjansson, pro/cons
    - in-memory representation of typed nodes (scalars, objects) is modified
      - document-based, output can be different based on execution path
      - difficult to use as basis for structure determination by static analysis
  - use Suricata itself to create wide variety of JSON
  - not exactly fuzztesting, rather "real-world" traffic
  - use results to derive schemas -> union across versions provides full field set
  - use field set to generate per-field documentation to be integrated with Suricata's RTD
  - bug discovery welcome, but not goal of this approach
  - fill approach with life: replace steps with specific tools/data/procedures:
    - input: pcaps w/ sources & stats
    - Suricata run: Docker w/links to Docker Hub and build scripts
    - Schemafication: GenSON
    - Version integration and templating: Python + Jinja2
    - Docu generation: Sphinx/RTD file layout and build process
  - quirks to be aware of 
    - dynamic JSON keys (metadata, flowbits/ints, stats threads)
    - fields dependent on run parameters (e.g. in_iface vs. pcap_filename)
    - fields dependent on configuration
    - Bugs
  
Results
  - stats of fields/counts: show graph
  - comments on versions and field additions/removals
  - Example RST text
  - Example Output as Sphinx page integrated in Suricata documentation

Summary/Outlook
  - Crowdsourcing approach
  - Integration into RTD: procedures and workflow
  - call for missing pcaps/features/fields submission